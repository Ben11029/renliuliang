<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šè®¾ç½®è§†å£ä»¥æ”¯æŒç§»åŠ¨è®¾å¤‡å’Œæ—‹è½¬ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äººæµé‡æ£€æµ‹ (AIç‰ˆ)</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <!-- âœ¨ å¼•å…¥ Chart.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <style>
        /* å…³é”®ï¼šè®©é¡µé¢å…¨å±å¹¶ç¦æ­¢æ»šåŠ¨ */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ»šåŠ¨æ¡ */
            background-color: #000; /* é»‘è‰²èƒŒæ™¯ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* å…³é”®ï¼šå®¹å™¨ç°åœ¨å¡«æ»¡æ•´ä¸ªå±å¹• */
        #container {
            position: fixed; /* å›ºå®šåœ¨å±å¹•ä¸Š */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* åœ¨åº•å±‚ */
        }

        /* å…³é”®ï¼šè§†é¢‘å’Œç”»å¸ƒä¹Ÿå¡«æ»¡å®¹å™¨ */
        video, canvas {
            position: absolute;
            top: 50%; /* âœ¨ æ”¹ä¸º50%ç”¨äºæ—‹è½¬å®šä½ */
            left: 50%; /* âœ¨ æ”¹ä¸º50%ç”¨äºæ—‹è½¬å®šä½ */
            width: 100%;
            height: 100%;
            /* âœ¨ æ–°å¢ï¼šç¡®ä¿æ—‹è½¬å’Œç¼©æ”¾æ­£ç¡®åº”ç”¨ */
            transform-origin: center center;
            /* âœ¨ ç»„åˆ transform å’Œ å°ºå¯¸ å˜åŒ– */
            transform: translate(-50%, -50%); 
            transition: transform 0.3s ease, width 0.3s ease, height 0.3s ease;
        }

        video {
            z-index: 1;
        }
        
        /* å…³é”®ï¼šä¸ºå‰ç½®æ‘„åƒå¤´é•œåƒç¿»è½¬ç”»å¸ƒ */
        canvas.mirrored {
             /* âœ¨ æ³¨æ„ï¼šæ—‹è½¬ä¼šè¦†ç›–è¿™ä¸ªï¼Œæˆ‘ä»¬åœ¨JSä¸­å¤„ç† */
            transform: translate(-50%, -50%) scaleX(-1);
        }

        canvas {
            z-index: 2;
            background-color: transparent;
        }

        /* å…³é”®ï¼šå·¦ä¸Šè§’çš„äººæ•°ç»Ÿè®¡æ¡† */
        #count-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: opacity 0.3s ease; /* âœ¨ ä¿æŒè¿‡æ¸¡æ•ˆæœ */
        }

        /* å°æ–¹æ¡†å†…çš„å…ƒç´ æ ·å¼ */
        #loading-message {
            margin: 0;
            font-size: 0.9em;
        }

        #count {
            margin: 0;
            font-size: 1.2em; 
            font-weight: bold;
            color: #00FFFF; /* äº®é’è‰²ï¼ŒåŒ¹é…æ–¹æ¡† */
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½åæ˜¾ç¤º */
        }

        /* æŒ‰é’®é€šç”¨æ ·å¼ */
        .info-button {
            padding: 8px 12px; 
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s ease, display 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            white-space: nowrap; /* é¿å…æŒ‰é’®æ–‡å­—æ¢è¡Œ */
        }

        /* --- âœ¨ ç§»é™¤: #top-left-buttons æ ·å¼ --- */
        /* #top-left-buttons { ... } å·²åˆ é™¤ */

        /* --- âœ¨ æ–°å¢: å³ä¸Šè§’æŒ‰é’®å®¹å™¨ --- */
        #top-right-buttons {
            position: absolute;
            top: 15px; 
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: column; /* å‚ç›´å †å  */
            gap: 10px;
            align-items: flex-end; /* æŒ‰é’®é å³ */
        }

        /* --- âœ¨ ä¿®æ”¹ï¼šåº•éƒ¨æ§åˆ¶æ  (ç°åœ¨æ˜¯å³ä¸‹è§’) --- */
        #controls-panel {
            position: absolute;
            bottom: 20px;
            right: 15px; /* âœ¨ æ”¹ä¸ºå³ä¾§ */
            /* transform: translateX(-50%); */ /* âœ¨ ç§»é™¤ */
            z-index: 10;
            display: flex;
            flex-wrap: wrap; 
            justify-content: flex-end; /* âœ¨ æ”¹ä¸ºå³å¯¹é½ */
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: background-color 0.3s ease;
        }

        /* "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®æ ·å¼ */
        #reportButton {
            background-color: #f44336; /* çº¢è‰² */
        }
        #reportButton:hover {
            background-color: #da190b;
        }

        /* ç¿»è½¬æŒ‰é’®æ ·å¼ */
        #flipButton {
            background-color: #9C27B0; /* ç´«è‰² */
        }
        #flipButton:hover {
            background-color: #7B1FA2;
        }

        /* âœ¨ æ—‹è½¬æŒ‰é’®æ ·å¼ */
        #rotateButton {
            background-color: #FF9800; /* æ©™è‰² */
        }
        #rotateButton:hover {
            background-color: #E68900;
        }

        /* é‡ç½®æŒ‰é’®æ ·å¼ */
        #resetButton {
            background-color: #007bff; /* è“è‰² */
        }
        #resetButton:hover {
            background-color: #0056b3;
        }
        
        /* å…¨å±æŒ‰é’®æ ·å¼ */
        #fullscreenButton {
            background-color: #607D8B; /* ç°è‰² */
        }
        #fullscreenButton:hover {
            background-color: #455A64;
        }

        /* é”å®šæŒ‰é’®æ ·å¼ */
        #lockButton {
            background-color: #4CAF50; /* ç»¿è‰² */
        }
        #lockButton:hover {
            background-color: #45a049;
        }

        /* --- æ¨¡æ€æ¡† (Modal) æ ·å¼ (æ— å˜åŒ–) --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
        }
        #gemini-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 90%; 
            max-width: 500px;
        }
        #gemini-modal h3 {
            margin-top: 0;
            color: #007bff;
        }
        #chart-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #chart-controls label {
            font-size: 0.9em;
            color: #555;
            font-weight: bold;
        }
        #chart-controls select {
            padding: 5px 8px;
            font-size: 0.9em;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        #chart-container {
            width: 100%;
            max-height: 400px; 
            position: relative;
            min-height: 100px; 
        }
        #chart-no-data {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 16px;
            text-align: center;
            width: 100%;
        }
        canvas:not(.modal-hidden) + #chart-no-data {
            display: none;
        }
        #close-modal-button {
            margin-top: 15px;
            padding: 8px 15px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            float: right; /* æŒ‰é’®é å³ */
        }
        .modal-hidden {
            display: none;
        }

    </style>
</head>
<body>
    
    <!-- è§†é¢‘å’Œç”»å¸ƒå®¹å™¨ (å…¨å±) -->
    <div id="container">
        <video autoplay playsinline muted id="webcam"></video>
        <canvas id="canvas"></canvas> 
    </div>
    
    <!-- å…³é”®ï¼šå·¦ä¸Šè§’ä¿¡æ¯æ¡† -->
    <div id="count-overlay">
        <p id="loading-message">æ­£åœ¨åŠ è½½AIæ¨¡å‹...</p>
        <h2 id="count">ç´¯è®¡äººæ•°: 0</h2>
    </div>

    <!-- âœ¨ æ–°å¢ï¼šå³ä¸Šè§’æŒ‰é’® -->
    <div id="top-right-buttons">
        <button id="flipButton" class="info-button">ğŸ”„ç¿»è½¬é•œå¤´</button>
        <button id="rotateButton" class="info-button">ğŸ”ƒæ—‹è½¬è§†é¢‘</button>
        <button id="fullscreenButton" class="info-button">ğŸ–¥ï¸å…¨å±æ˜¾ç¤º</button>
        <button id="lockButton" class="info-button">ğŸ”’é”å®šå±å¹•</button>
    </div>

    <!-- âœ¨ ä¿®æ”¹ï¼šåº•éƒ¨ä¸­å¤®æ§åˆ¶æ  -->
    <div id="controls-panel">
        <button id="reportButton" class="info-button">âœ¨ç”Ÿæˆå›¾è¡¨</button>
        <button id="resetButton" class="info-button">ğŸ†•é‡ç½®è®¡æ•°</button>
    </div>

    <!-- âœ¨ æ¨¡æ€æ¡† (Modal) -->
    <div id="modal-overlay" class="modal-hidden"></div>
    <div id="gemini-modal" class="modal-hidden">
        <h3 id="chart-modal-title">äººæµå›¾è¡¨</h3>
        <p class="text-gray-500 text-sm mt-2"><b>æ³¨ï¼š1. ç³»ç»Ÿè®¾ç½®ä¸º10åˆ†é’Ÿå†…é‡å¤å‡ºç°çš„äººä¸è®¡å…¥æ€»æ•°ï¼Œå¯é¿å…è¯¯å·®ã€‚</p>
          <p class="text-gray-500 text-sm mt-2"><b>  2. å¦å¤–ï¼Œåœºæ‰€å•ä¸ªå‡ºå…¥å£è¶…è¿‡10åˆ†é’Ÿçš„äººæµï¼Œåœ¨å‡ºå…¥æ—¶ä¼šè¢«åˆ†åˆ«è®¡æ•°ï¼Œæ•…å®é™…æœ€åäººæ•°å¯èƒ½éœ€è¦Ã·2.</p>
            <div id="chart-controls">
            <label for="chartIntervalSelect">é€‰æ‹©é—´éš”:</label>
            <select id="chartIntervalSelect">
                <option value="120000">æ¯2åˆ†é’Ÿ</option>
                <option value="300000">æ¯5åˆ†é’Ÿ</option>
                <option value="600000">æ¯10åˆ†é’Ÿ</option>
                <option value="1800000">æ¯30åˆ†é’Ÿ</option>
                <option value="3600000">æ¯1å°æ—¶</option>
            </select>
        </div>
        <div id="chart-container">
            <canvas id="chart-canvas"></canvas>
            <p id="chart-no-data" class="modal-hidden">æš‚æ— æ•°æ®ï¼Œè¯·è‡³å°‘ç­‰å¾…ä¸€ä¸ªå‘¨æœŸåå†è¯•ã€‚</p>
        </div>
        <button id="close-modal-button">å…³é—­</button>
    </div>

    <script>
        // è·å–HTMLä¸­çš„å…ƒç´ 
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const countDisplay = document.getElementById('count');
        const loadingMessage = document.getElementById('loading-message');
        
        // Modal å…ƒç´ 
        const modalOverlay = document.getElementById('modal-overlay');
        const geminiModal = document.getElementById('gemini-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const chartIntervalSelect = document.getElementById('chartIntervalSelect');
        
        // âœ¨ æ§åˆ¶æ å’Œæ‰€æœ‰æŒ‰é’® (æŒ‰æ–°å¸ƒå±€)
        const controlsPanel = document.getElementById('controls-panel'); // åº•éƒ¨
        const topRightButtons = document.getElementById('top-right-buttons'); // âœ¨ æ–°å¢
        
        const reportButton = document.getElementById('reportButton');
        const resetButton = document.getElementById('resetButton'); 
        
        const flipButton = document.getElementById('flipButton');
        const rotateButton = document.getElementById('rotateButton');
        const fullscreenButton = document.getElementById('fullscreenButton');
        const lockButton = document.getElementById('lockButton');

        let model = null; 
        let detectionTimeoutId = null; 
        const DETECTION_INTERVAL = 100; // 100æ¯«ç§’ = 10 FPS

        // --- è·Ÿè¸ªå™¨å˜é‡ ---
        let cumulativeCount = 0; 
        let nextPersonId = 1; 
        let trackedPeople = []; 
        let sessionStartTime = null; 
        
        // --- æ‘„åƒå¤´çŠ¶æ€å˜é‡ ---
        let currentFacingMode = 'environment'; // é»˜è®¤ä½¿ç”¨åç½®
        let currentStream = null; // å­˜å‚¨å½“å‰çš„è§†é¢‘æµ

        // --- âœ¨ æ—‹è½¬å’Œé”å®šçŠ¶æ€ ---
        let currentRotation = 0; // 0, 90, 180, 270
        let isLocked = false;

        const RELATIVE_MATCH_THRESHOLD = 0.8; 
        const MAX_FRAMES_UNSEEN = 100; // 100 å¸§ (10 ç§’)
        
        // --- å›¾è¡¨æ•°æ®ç›¸å…³å˜é‡ ---
        const BASE_LOG_INTERVAL = 60000; // å…³é”®ï¼šæ•°æ®è®°å½•åŸºç¡€é—´éš” (1 åˆ†é’Ÿ)
        let flowData = []; // å­˜å‚¨ { timestamp: Date, flow: int }
        let lastLoggedCount = 0;
        let dataLoggerInterval = null;
        let chartInstance = null; // å­˜å‚¨ Chart.js å®ä¾‹
        
        // --- Modal æ§åˆ¶å‡½æ•° (ä¸å˜) ---
        function showModal() {
            modalOverlay.classList.remove('modal-hidden');
            geminiModal.classList.remove('modal-hidden');
        }

        function hideModal() {
            modalOverlay.classList.add('modal-hidden');
            geminiModal.classList.add('modal-hidden'); 
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
        }
        
        // --- âœ¨ æ›´æ–°ï¼šé”å®š/è§£é”æ§ä»¶å‡½æ•° (æŒ‰æ–°å¸ƒå±€) ---
        function toggleLock() {
            isLocked = !isLocked; // ç¿»è½¬çŠ¶æ€
            
            // âœ¨ å®šä¹‰æ‰€æœ‰éœ€è¦éšè—/æ˜¾ç¤ºçš„æŒ‰é’®
            const buttonsToToggle = [
                // åº•éƒ¨æŒ‰é’®
                reportButton,
                resetButton,
                // å³ä¸Šè§’æŒ‰é’® (é™¤äº†é”å®š)
                flipButton,
                rotateButton,
                fullscreenButton
            ];

            buttonsToToggle.forEach(button => {
                button.style.display = isLocked ? 'none' : 'inline-block';
            });

            if (isLocked) {
                // --- é”å®š ---
                lockButton.innerText = "ğŸ”“ è§£é”";
                lockButton.style.backgroundColor = '#f44336'; // çº¢è‰²
                
                // âœ¨ åªéšè—åº•éƒ¨é¢æ¿çš„èƒŒæ™¯
                controlsPanel.style.backgroundColor = 'transparent';
                controlsPanel.style.boxShadow = 'none';
                
            } else {
                // --- è§£é” ---
                lockButton.innerText = "ğŸ”’é”å®šå±å¹•";
                lockButton.style.backgroundColor = '#4CAF50'; // ç»¿è‰²
                
                // âœ¨ æ¢å¤åº•éƒ¨é¢æ¿çš„èƒŒæ™¯
                controlsPanel.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                controlsPanel.style.boxShadow = '0 2px 8px rgba(0,0,0,0.5)';
            }
        }

        // --- å…¨å±åˆ‡æ¢å‡½æ•° (ä¸å˜) ---
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                const elem = document.documentElement; 
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { 
                    elem.webkitRequestFullscreen();
                }
                fullscreenButton.innerText = "â†©ï¸é€€å‡ºå…¨å±";
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { 
                    document.webkitExitFullscreen();
                }
                fullscreenButton.innerText = "ğŸ–¥ï¸å…¨å±æ˜¾ç¤º";
            }
        }

        // --- æ—‹è½¬å‡½æ•° (ä¸å˜) ---
        function toggleRotation() {
            currentRotation = (currentRotation + 90) % 360;

            if (currentRotation === 90 || currentRotation === 270) {
                video.style.width = '100vh';
                video.style.height = '100vw';
                canvas.style.width = '100vh';
                canvas.style.height = '100vw';
            } else {
                video.style.width = '100%';
                video.style.height = '100%';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
            }
            applyTransforms();
        }
        
        // --- åº”ç”¨å˜æ¢çš„è¾…åŠ©å‡½æ•° (ä¸å˜) ---
        function applyTransforms() {
            let videoTransform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;
            let canvasTransform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;

            if (currentFacingMode === 'user') {
                videoTransform += " scaleX(-1)";
                canvasTransform += " scaleX(-1)"; 
            }
            
            video.style.transform = videoTransform;
            canvas.style.transform = canvasTransform;

            if (currentFacingMode === 'user') {
                canvas.classList.add("mirrored"); 
            } else {
                canvas.classList.remove("mirrored");
            }
        }


        // --- ä¼šè¯æ—¶é•¿å‡½æ•° (ä¸å˜) ---
        function getSessionDuration() {
            if (!sessionStartTime) return "0 ç§’";
            const diff = new Date() - sessionStartTime;
            const seconds = Math.floor((diff / 1000) % 60);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            const hours = Math.floor((diff / (1000 * 60 * 60)));
            let durationStr = "";
            if (hours > 0) durationStr += `${hours} å°æ—¶ `;
            if (minutes > 0) durationStr += `${minutes} åˆ†é’Ÿ `;
            if (seconds > 0 || durationStr === "") durationStr += `${seconds} ç§’`;
            return durationStr.trim();
        }

        // --- è¾…åŠ©å‡½æ•° (ä¸å˜) ---
        function getBoxCenter(box) {
            return {
                x: box[0] + box[2] / 2,
                y: box[1] + box[3] / 2
            };
        }
        function getCenterDistance(center1, center2) {
            const dx = center1.x - center2.x;
            const dy = center1.y - center2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        function drawBoundingBox(box, personId, score) {
            const [x, y, width, height] = box;
            context.strokeStyle = '#00FFFF'; 
            context.lineWidth = 2;
            context.strokeRect(x, y, width, height); 
            
            context.fillStyle = '#00FFFF';
            context.font = '16px Arial';
            const label = `ID:${personId} (${Math.round(score * 100)}%)`;
            
            const textX = x;
            const textY = y > 16 ? y - 5 : 16;
            
            context.save(); 
            if (canvas.classList.contains("mirrored")) {
                const textWidth = context.measureText(label).width;
                context.translate(textX + (textWidth / 2), textY);
                context.scale(-1, 1);
                context.textAlign = "center";
                context.fillText(label, 0, 0);
            } else {
                context.textAlign = "left";
                context.fillText(label, textX, textY); 
            }
            context.restore(); 
        }

        // --- æ ¸å¿ƒæ£€æµ‹é€»è¾‘ (ä¸å˜) ---
        async function runDetection() {
            if (!model || !video.HAVE_ENOUGH_DATA) {
                detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
                return;
            }
            const predictions = await model.detect(video);
            context.clearRect(0, 0, canvas.width, canvas.height);
            let currentFramePeople = []; 
            for (let prediction of predictions) {
                if (prediction.class === 'person' && prediction.score > 0.5) { 
                    currentFramePeople.push({
                        box: prediction.bbox,
                        score: prediction.score,
                        center: getBoxCenter(prediction.bbox)
                    });
                }
            }
            let newTrackedPeople = []; 
            let matchedCurrentFrameIndices = new Set(); 
            for (let i = 0; i < trackedPeople.length; i++) {
                const trackedPerson = trackedPeople[i];
                let bestMatch = { index: -1, distance: Infinity };
                for (let j = 0; j < currentFramePeople.length; j++) {
                    if (matchedCurrentFrameIndices.has(j)) continue; 
                    const currentPerson = currentFramePeople[j];
                    const distance = getCenterDistance(currentPerson.center, trackedPerson.lastSeenCenter);
                    if (distance < bestMatch.distance) {
                        bestMatch = { index: j, distance: distance };
                    }
                }
                const personSize = (trackedPerson.lastSeenBox[2] + trackedPerson.lastSeenBox[3]) / 2;
                const MATCH_THRESHOLD = personSize * RELATIVE_MATCH_THRESHOLD;
                if (bestMatch.index !== -1 && bestMatch.distance < MATCH_THRESHOLD) {
                    const matchedCurrentPerson = currentFramePeople[bestMatch.index];
                    trackedPerson.lastSeenBox = matchedCurrentPerson.box;
                    trackedPerson.lastSeenCenter = matchedCurrentPerson.center;
                    trackedPerson.score = matchedCurrentPerson.score;
                    trackedPerson.framesUnseen = 0; 
                    newTrackedPeople.push(trackedPerson); 
                    matchedCurrentFrameIndices.add(bestMatch.index); 
                } else {
                    trackedPerson.framesUnseen++;
                    if (trackedPerson.framesUnseen < MAX_FRAMES_UNSEEN) {
                        newTrackedPeople.push(trackedPerson); 
                    }
                }
            }
            for (let i = 0; i < currentFramePeople.length; i++) {
                if (!matchedCurrentFrameIndices.has(i)) {
                    const newPerson = currentFramePeople[i];
                    cumulativeCount++; 
                    newTrackedPeople.push({
                        id: nextPersonId++, 
                        lastSeenBox: newPerson.box,
                        lastSeenCenter: newPerson.center,
                        score: newPerson.score,
                        framesUnseen: 0 
                    });
                }
            }
            trackedPeople = newTrackedPeople;
            for (const person of trackedPeople) {
                if (person.framesUnseen === 0) {
                    drawBoundingBox(person.lastSeenBox, person.id, person.score);
                }
            }
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
        }

        function stopDetection() {
            if (detectionTimeoutId) {
                clearTimeout(detectionTimeoutId);
                detectionTimeoutId = null;
            }
        }

        // --- æ•°æ®è®°å½•å™¨åŠŸèƒ½ (ä¸å˜) ---
        function logData() {
            const currentFlow = cumulativeCount - lastLoggedCount;
            flowData.push({ 
                timestamp: new Date(), 
                flow: currentFlow 
            });
            lastLoggedCount = cumulativeCount;
            console.log('å·²è®°å½•äººæµæ•°æ®(æ¯1åˆ†é’Ÿ):', flowData[flowData.length - 1]);
        }

        function startDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            flowData = [];
            lastLoggedCount = 0;
            
            console.log(`æ•°æ®è®°å½•å™¨å·²å¯åŠ¨ï¼Œæ¯ 1 åˆ†é’Ÿè®°å½•ä¸€æ¬¡ã€‚`);
            dataLoggerInterval = setInterval(logData, BASE_LOG_INTERVAL);
        }

        function stopDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            dataLoggerInterval = null;
            console.log('æ•°æ®è®°å½•å™¨å·²åœæ­¢ã€‚');
        } 
        
        // --- å›¾è¡¨æ•°æ®èšåˆå‡½æ•° (ä¸å˜) ---
        function aggregateData(targetIntervalMs) {
            const aggregationFactor = targetIntervalMs / BASE_LOG_INTERVAL;
            if (flowData.length === 0) {
                return { labels: [], data: [] };
            }
            if (aggregationFactor < 1) {
                 console.warn("èšåˆé—´éš”å°äºåŸºç¡€é—´éš”");
                 return { labels: [], data: [] };
            }

            let aggregatedFlow = [];
            let aggregatedLabels = [];
            let currentFlowSum = 0;
            let lastTimestamp = null;

            for (let i = 0; i < flowData.length; i++) {
                currentFlowSum += flowData[i].flow;
                lastTimestamp = flowData[i].timestamp;
                
                if ((i + 1) % aggregationFactor === 0 || i === flowData.length - 1) {
                    aggregatedFlow.push(currentFlowSum);
                    aggregatedLabels.push(lastTimestamp.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }));
                    currentFlowSum = 0; // é‡ç½®æ€»å’Œ
                }
            }
            return { labels: aggregatedLabels, data: aggregatedFlow };
        }

        
        // --- å›¾è¡¨æ¸²æŸ“å‡½æ•° (ä¸å˜) ---
        function renderChart() {
            const chartCanvas = document.getElementById('chart-canvas');
            const noDataText = document.getElementById('chart-no-data');
            
            const selectedIntervalMs = parseInt(chartIntervalSelect.value, 10);
            const selectedIntervalText = chartIntervalSelect.options[chartIntervalSelect.selectedIndex].text;

            document.getElementById('chart-modal-title').innerText = `äººæµå›¾è¡¨ (${selectedIntervalText})`;

            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }

            const { labels, data } = aggregateData(selectedIntervalMs);

            if (data.length === 0) {
                noDataText.classList.remove('modal-hidden'); 
                chartCanvas.classList.add('modal-hidden'); 
                return; 
            }

            noDataText.classList.add('modal-hidden'); 
            chartCanvas.classList.remove('modal-hidden'); 

            requestAnimationFrame(() => {
                const ctx = chartCanvas.getContext('2d');
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `æ¯ ${selectedIntervalText.replace('æ¯', '')} æ–°å¢äººæµ`,
                            data: data,
                            fill: true,
                            backgroundColor: 'rgba(0, 123, 255, 0.2)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 2,
                            tension: 0.1 
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'æ–°å¢äººæ•°' },
                                ticks: { stepSize: 1 }
                            },
                            x: {
                                title: { display: true, text: 'æ—¶é—´ç‚¹ (å‘¨æœŸç»“æŸæ—¶)' }
                            }
                        }
                    }
                });
            });
        }


        // --- é‡ç½®è·Ÿè¸ªå™¨çŠ¶æ€çš„å‡½æ•° (ä¸å˜) ---
        function resetTrackerState() {
            cumulativeCount = 0;
            nextPersonId = 1; 
            trackedPeople = []; 
            sessionStartTime = new Date(); 
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            context.clearRect(0, 0, canvas.width, canvas.height); 
            
            stopDataLogger();
            startDataLogger();
        }

        // --- å¯åŠ¨æ‘„åƒå¤´çš„å‡½æ•° (ä¸å˜) ---
        async function startCamera(facingMode) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            currentFacingMode = facingMode; 
            const constraints = { 
                video: { 
                    facingMode: currentFacingMode,
                    width: { ideal: 640 }, 
                    height: { ideal: 480 },
                    maxWidth: 640,
                    maxHeight: 480
                },
                audio: false 
            };
            
            if (currentRotation === 90 || currentRotation === 270) {
                video.style.width = '100vh';
                video.style.height = '100vw';
                canvas.style.width = '100vh';
                canvas.style.height = '100vw';
            } else {
                video.style.width = '100%';
                video.style.height = '100%';
                canvas.style.width = '100%';
                canvas.style.height = '100%';
            }
            applyTransforms();

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream; 
                video.srcObject = stream;
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        
                        console.log(`æ‘„åƒå¤´å·²å¯åŠ¨ (${currentFacingMode}): ${video.videoWidth}x${video.videoHeight}`);
                        resolve(true);
                    };
                    video.onerror = (e) => {
                        console.error("è§†é¢‘å…ƒç´ é”™è¯¯:", e);
                        reject(new Error("è§†é¢‘åŠ è½½æµå¤±è´¥ã€‚"));
                    };
                });
            } catch (error) {
                console.error("getUserMedia é”™è¯¯:", error);
                loadingMessage.innerText = `é”™è¯¯: ${error.message}`;
                throw error; 
            }
        }

        // --- âœ¨ æ›´æ–°ï¼šä¸»å¯åŠ¨å‡½æ•° (æŒ‰æ–°å¸ƒå±€) ---
        async function main() {
            try {
                console.log('æ­£åœ¨åŠ è½½æ¨¡å‹...');
                model = await cocoSsd.load();
                console.log('æ¨¡å‹åŠ è½½å®Œæ¯•ã€‚');
                loadingMessage.innerText = 'æ¨¡å‹åŠ è½½å®Œæ¯•...';

                await startCamera(currentFacingMode); 
                
                loadingMessage.style.display = 'none'; 
                countDisplay.style.display = 'block'; 
                controlsPanel.style.display = 'flex'; // âœ¨ æ˜¾ç¤ºåº•éƒ¨
                topRightButtons.style.display = 'flex'; // âœ¨ æ˜¾ç¤ºå³ä¸Š
                
                sessionStartTime = new Date(); 
                startDataLogger(); 
                runDetection(); 
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // å¯åŠ¨ç¨‹åº
        main();

        // --- âœ¨ äº‹ä»¶ç›‘å¬å™¨ (å·²æ›´æ–°) ---

        // å…³é—­æ¨¡æ€æ¡†
        closeModalButton.addEventListener('click', hideModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                hideModal();
            }
        });

        // é‡ç½®æŒ‰é’®
        resetButton.addEventListener('click', () => {
            console.log('è®¡æ•°å·²é‡ç½®');
            stopDetection(); 
            resetTrackerState(); 
            runDetection(); 
        });
        
        // ç¿»è½¬æ‘„åƒå¤´æŒ‰é’®
        flipButton.addEventListener('click', async () => {
            console.log('æ­£åœ¨ç¿»è½¬æ‘„åƒå¤´...');
            stopDetection(); 
            stopDataLogger(); 

            loadingMessage.innerText = 'æ­£åœ¨ç¿»è½¬é•œå¤´...';
            loadingMessage.style.display = 'block';
            countDisplay.style.display = 'none';
            controlsPanel.style.display = 'none';
            topRightButtons.style.display = 'none'; // âœ¨ éšè—
            
            try {
                const newFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                await startCamera(newFacingMode); 
                
                resetTrackerState(); 
                
                loadingMessage.style.display = 'none';
                countDisplay.style.display = 'block';
                controlsPanel.style.display = 'flex';
                topRightButtons.style.display = 'flex'; // âœ¨ æ¢å¤æ˜¾ç¤º
                
                runDetection(); 
                
            } catch (error) {
                console.error('ç¿»è½¬æ‘„åƒå¤´å¤±è´¥:', error);
                loadingMessage.innerText = `ç¿»è½¬å¤±è´¥: ${error.message}`;
                controlsPanel.style.display = 'flex';
                topRightButtons.style.display = 'flex'; // âœ¨ æ¢å¤æ˜¾ç¤º
            }
        });

        // "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®
        reportButton.addEventListener('click', () => {
            showModal();
            chartIntervalSelect.value = "300000"; // é»˜è®¤5åˆ†é’Ÿ
            renderChart(); 
        });

        // æ¨¡æ€æ¡†å†…éƒ¨ä¸‹æ‹‰èœå•
        chartIntervalSelect.addEventListener('change', () => {
            renderChart(); 
        });

        // å…¨å±æŒ‰é’®
        fullscreenButton.addEventListener('click', toggleFullScreen);
        
        // é”å®šæŒ‰é’®
        lockButton.addEventListener('click', toggleLock);

        // æ—‹è½¬æŒ‰é’®
        rotateButton.addEventListener('click', toggleRotation);

        // æ—‹è½¬å¤„ç† (ä¸å˜)
        const resizeObserver = new ResizeObserver(() => {
            if (video.videoWidth > 0 && 
                (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)) {
                
                console.log(`æ£€æµ‹åˆ°æ—‹è½¬/è°ƒæ•´å¤§å°ã€‚é‡è®¾ç”»å¸ƒåˆ†è¾¨ç‡ä¸º: ${video.videoWidth}x${video.videoHeight}`);
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
        });
        resizeObserver.observe(video);
    </script>
</body>
</html>