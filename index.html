<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šè®¾ç½®è§†å£ä»¥æ”¯æŒç§»åŠ¨è®¾å¤‡å’Œæ—‹è½¬ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äººæµé‡æ£€æµ‹ (âœ¨ AIç‰ˆ)</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <!-- âœ¨ å¼•å…¥ Chart.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <style>
        /* å…³é”®ï¼šè®©é¡µé¢å…¨å±å¹¶ç¦æ­¢æ»šåŠ¨ */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ»šåŠ¨æ¡ */
            background-color: #000; /* é»‘è‰²èƒŒæ™¯ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* å…³é”®ï¼šå®¹å™¨ç°åœ¨å¡«æ»¡æ•´ä¸ªå±å¹• */
        #container {
            position: fixed; /* å›ºå®šåœ¨å±å¹•ä¸Š */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* åœ¨åº•å±‚ */
        }

        /* å…³é”®ï¼šè§†é¢‘å’Œç”»å¸ƒä¹Ÿå¡«æ»¡å®¹å™¨ */
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        video {
            z-index: 1;
            /* é€‚é…å‰ç½®æ‘„åƒå¤´é•œåƒ */
            transform: scaleX(1); 
        }
        
        /* å…³é”®ï¼šä¸ºå‰ç½®æ‘„åƒå¤´é•œåƒç¿»è½¬ç”»å¸ƒ */
        canvas.mirrored {
            transform: scaleX(-1);
        }

        canvas {
            z-index: 2;
            background-color: transparent;
        }

        /* --- âœ¨ å¸ƒå±€æ”¹åŠ¨ --- */

        /* å…³é”®ï¼šå·¦ä¸Šè§’çš„äººæ•°ç»Ÿè®¡æ¡† */
        #count-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
            transition: opacity 0.3s ease; /* âœ¨ å¢åŠ è¿‡æ¸¡æ•ˆæœ */
        }

        /* å°æ–¹æ¡†å†…çš„å…ƒç´ æ ·å¼ */
        #loading-message {
            margin: 0;
            font-size: 0.9em;
        }

        #count {
            margin: 0;
            font-size: 1.2em; 
            font-weight: bold;
            color: #00FFFF; /* äº®é’è‰²ï¼ŒåŒ¹é…æ–¹æ¡† */
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½åæ˜¾ç¤º */
        }

        /* å…³é”®ï¼šå³ä¸‹è§’çš„æŒ‰é’®æ§åˆ¶æ¡† */
        #controls-overlay {
            position: absolute;
            bottom: 20px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: row; /* æ°´å¹³æ’åˆ— */
            gap: 10px; /* æŒ‰é’®é—´è· */
            align-items: center; /* âœ¨ å‚ç›´å±…ä¸­å¯¹é½ */
            transition: opacity 0.3s ease; /* âœ¨ å¢åŠ è¿‡æ¸¡æ•ˆæœ */
        }

        /* æŒ‰é’®é€šç”¨æ ·å¼ */
        .info-button {
            padding: 8px 12px; 
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s ease; /* âœ¨ å¢åŠ è¿‡æ¸¡æ•ˆæœ */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®æ ·å¼ */
        #reportButton {
            background-color: #f44336; /* çº¢è‰² */
        }
        #reportButton:hover {
            background-color: #da190b;
        }

        /* ç¿»è½¬æŒ‰é’®æ ·å¼ */
        #flipButton {
            background-color: #9C27B0; /* ç´«è‰² */
        }
        #flipButton:hover {
            background-color: #7B1FA2;
        }

        /* é‡ç½®æŒ‰é’®æ ·å¼ */
        #resetButton {
            background-color: #007bff; /* è“è‰² */
        }
        #resetButton:hover {
            background-color: #0056b3;
        }
        
        
        /* --- âœ¨ æ¨¡æ€æ¡† (Modal) æ ·å¼ä¿®æ”¹ --- */
        
        /* æ¨¡æ€æ¡†é®ç½©å±‚ */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
        }

        /* æ¨¡æ€æ¡†æœ¬ä½“ */
        #gemini-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 90%; /* é€‚é…æ‰‹æœºå®½åº¦ */
            max-width: 500px;
        }
        
        /* âœ¨ æ¨¡æ€æ¡†æ ‡é¢˜ (å·²æ·»åŠ ID) */
        #gemini-modal h3 {
            margin-top: 0;
            color: #007bff;
        }

        /* âœ¨ æ–°å¢ï¼šæ¨¡æ€æ¡†å†…éƒ¨çš„æ§åˆ¶æ  */
        #chart-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #chart-controls label {
            font-size: 0.9em;
            color: #555;
            font-weight: bold;
        }
        #chart-controls select {
            padding: 5px 8px;
            font-size: 0.9em;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        /* âœ¨ æ–°å¢å›¾è¡¨å®¹å™¨æ ·å¼ */
        #chart-container {
            width: 100%;
            max-height: 400px; /* é™åˆ¶å›¾è¡¨æœ€å¤§é«˜åº¦ */
            position: relative; /* âœ¨ è®¾ä¸ºç›¸å¯¹å®šä½ï¼Œç”¨äºå†…éƒ¨å…ƒç´ å®šä½ */
            min-height: 100px; /* âœ¨ é¿å…æ— æ•°æ®æ—¶é«˜åº¦åå¡Œ */
        }
        
        /* âœ¨ æ–°å¢ï¼šæ— æ•°æ®æ—¶çš„æç¤ºæ–‡æœ¬ */
        #chart-no-data {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 16px;
            text-align: center;
            width: 100%;
        }

        /* âœ¨ å½“ç”»å¸ƒæ˜¾ç¤ºæ—¶ï¼Œéšè—æ— æ•°æ®æç¤º */
        canvas:not(.modal-hidden) + #chart-no-data {
            display: none;
        }

        #close-modal-button {
            margin-top: 15px;
            padding: 8px 15px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            float: right; /* æŒ‰é’®é å³ */
        }
        
        .modal-hidden {
            display: none;
        }
        /* --- ç»“æŸï¼šæ¨¡æ€æ¡†æ ·å¼ --- */

        /* âœ¨ æ–°å¢ï¼šå³ä¸Šè§’æ§åˆ¶å®¹å™¨ */
        #top-right-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: column; /* å‚ç›´æ’åˆ— */
            gap: 10px; /* æŒ‰é’®é—´è· */
            align-items: flex-end; /* å³å¯¹é½ */
        }

        /* âœ¨ ä¿®æ”¹ï¼šå…¨å±æŒ‰é’®æ ·å¼ (ç§»é™¤å®šä½) */
        #fullscreenButton {
            background-color: #607D8B; /* ç°è‰² */
        }
        #fullscreenButton:hover {
            background-color: #455A64;
        }

        /* âœ¨ æ–°å¢ï¼šé”å®šæŒ‰é’®æ ·å¼ */
        #lockButton {
            background-color: #4CAF50; /* ç»¿è‰² */
        }
        #lockButton:hover {
            background-color: #45a049;
        }
        
        /* âœ¨ æ–°å¢ï¼šç”¨äºéšè—æ§ä»¶çš„ç±» */
        .controls-hidden {
            opacity: 0;
            pointer-events: none; /* éšè—æ—¶ä¸å¯ç‚¹å‡» */
        }

    </style>
</head>
<body>
    
    <!-- è§†é¢‘å’Œç”»å¸ƒå®¹å™¨ (å…¨å±) -->
    <div id="container">
        <video autoplay playsinline muted id="webcam"></video>
        <canvas id="canvas"></canvas> 
    </div>
    
    <!-- å…³é”®ï¼šå·¦ä¸Šè§’ä¿¡æ¯æ¡† -->
    <div id="count-overlay">
        <p id="loading-message">æ­£åœ¨åŠ è½½AIæ¨¡å‹...</p>
        <h2 id="count">ç´¯è®¡äººæ•°: 0</h2>
    </div>

    <!-- å…³é”®ï¼šå³ä¸‹è§’æ§åˆ¶æ¡† -->
    <div id="controls-overlay">
        <button id="reportButton" class="info-button">âœ¨ç”Ÿæˆå›¾è¡¨</button>
        <button id="flipButton" class="info-button">ğŸ”„ç¿»è½¬é•œå¤´</button>
        <button id="resetButton" class="info-button">ğŸ†•é‡ç½®è®¡æ•°</button>
    </div>

    <!-- âœ¨ æ–°å¢ï¼šå³ä¸Šè§’æ§åˆ¶æ¡† (åŒ…å«å…¨å±å’Œé”å®š) -->
    <div id="top-right-controls">
        <button id="fullscreenButton" class="info-button">ğŸ–¥ï¸å…¨å±</button>
        <button id="lockButton" class="info-button">ğŸ”’é”å®š</button>
    </div>

    <!-- âœ¨ æ¨¡æ€æ¡† (Modal) -->
    <div id="modal-overlay" class="modal-hidden"></div>
    <div id="gemini-modal" class="modal-hidden">
        <h3 id="chart-modal-title">äººæµå›¾è¡¨</h3>
        <div id="chart-controls">
            <label for="chartIntervalSelect">é€‰æ‹©é—´éš”:</label>
            <select id="chartIntervalSelect">
                <option value="120000">æ¯2åˆ†é’Ÿ</option>
                <option value="300000">æ¯5åˆ†é’Ÿ</option>
                <option value="600000">æ¯10åˆ†é’Ÿ</option>
                <option value="1800000">æ¯30åˆ†é’Ÿ</option>
                <option value="3600000">æ¯å°æ—¶</option>
            </select>
        </div>
        <div id="chart-container">
            <canvas id="chart-canvas"></canvas>
            <p id="chart-no-data" class="modal-hidden">æš‚æ— æ•°æ®ï¼Œè¯·è‡³å°‘ç­‰å¾…ä¸€ä¸ªå‘¨æœŸåå†è¯•ã€‚</p>
        </div>
        <button id="close-modal-button">å…³é—­</button>
    </div>

    <script>
        // è·å–HTMLä¸­çš„å…ƒç´ 
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const countDisplay = document.getElementById('count');
        const loadingMessage = document.getElementById('loading-message');
        const resetButton = document.getElementById('resetButton'); 

        // æŒ‰é’®
        const reportButton = document.getElementById('reportButton');
        
        // Modal å…ƒç´ 
        const modalOverlay = document.getElementById('modal-overlay');
        const geminiModal = document.getElementById('gemini-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const chartIntervalSelect = document.getElementById('chartIntervalSelect');
        
        // ç¿»è½¬æŒ‰é’®
        const flipButton = document.getElementById('flipButton');
        
        // å…¨å±æŒ‰é’®
        const fullscreenButton = document.getElementById('fullscreenButton');
        
        // âœ¨ æ–°å¢ï¼šé”å®šæŒ‰é’®å’Œéœ€è¦éšè—çš„å…ƒç´ 
        const lockButton = document.getElementById('lockButton');
        const countOverlay = document.getElementById('count-overlay');
        const controlsOverlay = document.getElementById('controls-overlay');

        let model = null; 
        let detectionTimeoutId = null; 
        const DETECTION_INTERVAL = 100; // 100æ¯«ç§’ = 10 FPS

        // --- è·Ÿè¸ªå™¨å˜é‡ ---
        let cumulativeCount = 0; 
        let nextPersonId = 1; 
        let trackedPeople = []; 
        let sessionStartTime = null; 
        
        // --- æ‘„åƒå¤´çŠ¶æ€å˜é‡ ---
        let currentFacingMode = 'environment'; // é»˜è®¤ä½¿ç”¨åç½®
        let currentStream = null; // å­˜å‚¨å½“å‰çš„è§†é¢‘æµ

        const RELATIVE_MATCH_THRESHOLD = 0.8; 
        const MAX_FRAMES_UNSEEN = 100; // 100 å¸§ (10 ç§’)
        
        // --- å›¾è¡¨æ•°æ®ç›¸å…³å˜é‡ ---
        const BASE_LOG_INTERVAL = 60000; // å…³é”®ï¼šæ•°æ®è®°å½•åŸºç¡€é—´éš” (1 åˆ†é’Ÿ)
        let flowData = []; // å­˜å‚¨ { timestamp: Date, flow: int }
        let lastLoggedCount = 0;
        let dataLoggerInterval = null;
        let chartInstance = null; // å­˜å‚¨ Chart.js å®ä¾‹
        
        // âœ¨ æ–°å¢ï¼šé”å®šçŠ¶æ€
        let isLocked = false;

        // --- Modal æ§åˆ¶å‡½æ•° (ä¸å˜) ---
        function showModal() {
            modalOverlay.classList.remove('modal-hidden');
            geminiModal.classList.remove('modal-hidden');
        }

        function hideModal() {
            modalOverlay.classList.add('modal-hidden');
            geminiModal.classList.add('modal-hidden'); 
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
        }
        
        // âœ¨ æ–°å¢ï¼šé”å®š/è§£é”æ§ä»¶å‡½æ•°
        function toggleLock() {
            isLocked = !isLocked; // ç¿»è½¬çŠ¶æ€

            if (isLocked) {
                // --- é”å®š ---
                countOverlay.classList.add('controls-hidden');
                controlsOverlay.classList.add('controls-hidden');
                fullscreenButton.classList.add('controls-hidden');
                
                lockButton.innerText = "ğŸ”“ è§£é”";
                lockButton.style.backgroundColor = '#f44336'; // çº¢è‰²
                lockButton.style.color = '#fff';
            } else {
                // --- è§£é” ---
                countOverlay.classList.remove('controls-hidden');
                controlsOverlay.classList.remove('controls-hidden');
                fullscreenButton.classList.remove('controls-hidden');
                
                lockButton.innerText = "ğŸ”’ é”å®š";
                lockButton.style.backgroundColor = '#4CAF50'; // ç»¿è‰²
            }
        }

        // --- å…¨å±åˆ‡æ¢å‡½æ•° (ä¸å˜) ---
        function toggleFullScreen() {
            if (!document.fullscreenElement && 
                !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && 
                !document.msFullscreenElement) {
                // --- è¿›å…¥å…¨å± ---
                const elem = document.documentElement; // æ•´ä¸ªé¡µé¢
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.mozRequestFullScreen) { /* Firefox */
                    elem.mozRequestFullScreen();
                } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE/Edge */
                    elem.msRequestFullscreen();
                }
                fullscreenButton.innerText = "é€€å‡ºå…¨å±";
            } else {
                // --- é€€å‡ºå…¨å± ---
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { /* Firefox */
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { /* Chrome, Safari & Opera */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE/Edge */
                    document.msExitFullscreen();
                }
                fullscreenButton.innerText = "ğŸ–¥ï¸ å…¨å±";
            }
        }

        // --- ä¼šè¯æ—¶é•¿å‡½æ•° (ä¸å˜) ---
        function getSessionDuration() {
            if (!sessionStartTime) return "0 ç§’";
            const diff = new Date() - sessionStartTime;
            const seconds = Math.floor((diff / 1000) % 60);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            const hours = Math.floor((diff / (1000 * 60 * 60)));
            let durationStr = "";
            if (hours > 0) durationStr += `${hours} å°æ—¶ `;
            if (minutes > 0) durationStr += `${minutes} åˆ†é’Ÿ `;
            if (seconds > 0 || durationStr === "") durationStr += `${seconds} ç§’`;
            return durationStr.trim();
        }

        // --- è¾…åŠ©å‡½æ•° (ä¸å˜) ---
        function getBoxCenter(box) {
            return {
                x: box[0] + box[2] / 2,
                y: box[1] + box[3] / 2
            };
        }
        function getCenterDistance(center1, center2) {
            const dx = center1.x - center2.x;
            const dy = center1.y - center2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        function drawBoundingBox(box, personId, score) {
            const [x, y, width, height] = box;
            context.strokeStyle = '#00FFFF'; 
            context.lineWidth = 2;
            context.strokeRect(x, y, width, height); 
            
            context.fillStyle = '#00FFFF';
            context.font = '16px Arial';
            const label = `ID:${personId} (${Math.round(score * 100)}%)`;
            
            const textX = x;
            const textY = y > 16 ? y - 5 : 16;
            
            context.save(); 
            if (currentFacingMode === 'user') {
                const textWidth = context.measureText(label).width;
                context.translate(textX + (textWidth / 2), textY);
                context.scale(-1, 1);
                context.textAlign = "center";
                context.fillText(label, 0, 0);
            } else {
                context.textAlign = "left";
                context.fillText(label, textX, textY); 
            }
            context.restore(); 
        }

        // --- æ ¸å¿ƒæ£€æµ‹é€»è¾‘ (ä¸å˜) ---
        async function runDetection() {
            if (!model || !video.HAVE_ENOUGH_DATA) {
                detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
                return;
            }
            const predictions = await model.detect(video);
            context.clearRect(0, 0, canvas.width, canvas.height);
            let currentFramePeople = []; 
            for (let prediction of predictions) {
                if (prediction.class === 'person' && prediction.score > 0.5) { 
                    currentFramePeople.push({
                        box: prediction.bbox,
                        score: prediction.score,
                        center: getBoxCenter(prediction.bbox)
                    });
                }
            }
            let newTrackedPeople = []; 
            let matchedCurrentFrameIndices = new Set(); 
            for (let i = 0; i < trackedPeople.length; i++) {
                const trackedPerson = trackedPeople[i];
                let bestMatch = { index: -1, distance: Infinity };
                for (let j = 0; j < currentFramePeople.length; j++) {
                    if (matchedCurrentFrameIndices.has(j)) continue; 
                    const currentPerson = currentFramePeople[j];
                    const distance = getCenterDistance(currentPerson.center, trackedPerson.lastSeenCenter);
                    if (distance < bestMatch.distance) {
                        bestMatch = { index: j, distance: distance };
                    }
                }
                const personSize = (trackedPerson.lastSeenBox[2] + trackedPerson.lastSeenBox[3]) / 2;
                const MATCH_THRESHOLD = personSize * RELATIVE_MATCH_THRESHOLD;
                if (bestMatch.index !== -1 && bestMatch.distance < MATCH_THRESHOLD) {
                    const matchedCurrentPerson = currentFramePeople[bestMatch.index];
                    trackedPerson.lastSeenBox = matchedCurrentPerson.box;
                    trackedPerson.lastSeenCenter = matchedCurrentPerson.center;
                    trackedPerson.score = matchedCurrentPerson.score;
                    trackedPerson.framesUnseen = 0; 
                    newTrackedPeople.push(trackedPerson); 
                    matchedCurrentFrameIndices.add(bestMatch.index); 
                } else {
                    trackedPerson.framesUnseen++;
                    if (trackedPerson.framesUnseen < MAX_FRAMES_UNSEEN) {
                        newTrackedPeople.push(trackedPerson); 
                    }
                }
            }
            for (let i = 0; i < currentFramePeople.length; i++) {
                if (!matchedCurrentFrameIndices.has(i)) {
                    const newPerson = currentFramePeople[i];
                    cumulativeCount++; 
                    newTrackedPeople.push({
                        id: nextPersonId++, 
                        lastSeenBox: newPerson.box,
                        lastSeenCenter: newPerson.center,
                        score: newPerson.score,
                        framesUnseen: 0 
                    });
                }
            }
            trackedPeople = newTrackedPeople;
            for (const person of trackedPeople) {
                if (person.framesUnseen === 0) {
                    drawBoundingBox(person.lastSeenBox, person.id, person.score);
                }
            }
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
        }

        function stopDetection() {
            if (detectionTimeoutId) {
                clearTimeout(detectionTimeoutId);
                detectionTimeoutId = null;
            }
        }

        // --- æ•°æ®è®°å½•å™¨åŠŸèƒ½ (ä¸å˜) ---
        function logData() {
            const currentFlow = cumulativeCount - lastLoggedCount;
            flowData.push({ 
                timestamp: new Date(), 
                flow: currentFlow 
            });
            lastLoggedCount = cumulativeCount;
            console.log('å·²è®°å½•äººæµæ•°æ®(æ¯1åˆ†é’Ÿ):', flowData[flowData.length - 1]);
        }

        function startDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            flowData = [];
            lastLoggedCount = 0;
            
            console.log(`æ•°æ®è®°å½•å™¨å·²å¯åŠ¨ï¼Œæ¯ 1 åˆ†é’Ÿè®°å½•ä¸€æ¬¡ã€‚`);
            dataLoggerInterval = setInterval(logData, BASE_LOG_INTERVAL);
        }

        function stopDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            dataLoggerInterval = null;
            console.log('æ•°æ®è®°å½•å™¨å·²åœæ­¢ã€‚');
        } 
        
        // --- å›¾è¡¨æ•°æ®èšåˆå‡½æ•° (ä¸å˜) ---
        function aggregateData(targetIntervalMs) {
            const aggregationFactor = targetIntervalMs / BASE_LOG_INTERVAL;
            if (flowData.length === 0) {
                return { labels: [], data: [] };
            }
            if (aggregationFactor < 1) {
                 console.warn("èšåˆé—´éš”å°äºåŸºç¡€é—´éš”");
                 return { labels: [], data: [] };
            }

            let aggregatedFlow = [];
            let aggregatedLabels = [];
            let currentFlowSum = 0;
            let lastTimestamp = null;

            for (let i = 0; i < flowData.length; i++) {
                currentFlowSum += flowData[i].flow;
                lastTimestamp = flowData[i].timestamp;
                
                if ((i + 1) % aggregationFactor === 0 || i === flowData.length - 1) {
                    aggregatedFlow.push(currentFlowSum);
                    aggregatedLabels.push(lastTimestamp.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }));
                    currentFlowSum = 0; // é‡ç½®æ€»å’Œ
                }
            }
            return { labels: aggregatedLabels, data: aggregatedFlow };
        }

        
        // --- å›¾è¡¨æ¸²æŸ“å‡½æ•° (ä¸å˜) ---
        function renderChart() {
            const chartCanvas = document.getElementById('chart-canvas');
            const noDataText = document.getElementById('chart-no-data');
            
            const selectedIntervalMs = parseInt(chartIntervalSelect.value, 10);
            const selectedIntervalText = chartIntervalSelect.options[chartIntervalSelect.selectedIndex].text;

            document.getElementById('chart-modal-title').innerText = `äººæµå›¾è¡¨ (${selectedIntervalText})`;

            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }

            const { labels, data } = aggregateData(selectedIntervalMs);

            if (data.length === 0) {
                noDataText.classList.remove('modal-hidden'); 
                chartCanvas.classList.add('modal-hidden'); 
                return; 
            }

            noDataText.classList.add('modal-hidden'); 
            chartCanvas.classList.remove('modal-hidden'); 

            requestAnimationFrame(() => {
                const ctx = chartCanvas.getContext('2d');
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `æ¯ ${selectedIntervalText.replace('æ¯', '')} æ–°å¢äººæµ`,
                            data: data,
                            fill: true,
                            backgroundColor: 'rgba(0, 123, 255, 0.2)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 2,
                            tension: 0.1 
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'æ–°å¢äººæ•°' },
                                ticks: { stepSize: 1 }
                            },
                            x: {
                                title: { display: true, text: 'æ—¶é—´ç‚¹ (å‘¨æœŸç»“æŸæ—¶)' }
                            }
                        }
                    }
                });
            });
        }


        // --- é‡ç½®è·Ÿè¸ªå™¨çŠ¶æ€çš„å‡½æ•° (ä¸å˜) ---
        function resetTrackerState() {
            cumulativeCount = 0;
            nextPersonId = 1; 
            trackedPeople = []; 
            sessionStartTime = new Date(); 
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            context.clearRect(0, 0, canvas.width, canvas.height); 
            
            stopDataLogger();
            startDataLogger();
        }

        // --- å¯åŠ¨æ‘„åƒå¤´çš„å‡½æ•° (ä¸å˜) ---
        async function startCamera(facingMode) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            currentFacingMode = facingMode; 
            const constraints = { 
                video: { 
                    facingMode: currentFacingMode,
                    width: { ideal: 640 }, 
                    height: { ideal: 480 },
                    maxWidth: 640,
                    maxHeight: 480
                },
                audio: false 
            };
            
            if (currentFacingMode === 'user') {
                video.style.transform = "scaleX(-1)";
                canvas.classList.add("mirrored");
            } else {
                video.style.transform = "scaleX(1)";
                canvas.classList.remove("mirrored");
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream; 
                video.srcObject = stream;
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        console.log(`æ‘„åƒå¤´å·²å¯åŠ¨ (${currentFacingMode}): ${video.videoWidth}x${video.videoHeight}`);
                        resolve(true);
                    };
                    video.onerror = (e) => {
                        console.error("è§†é¢‘å…ƒç´ é”™è¯¯:", e);
                        reject(new Error("è§†é¢‘åŠ è½½æµå¤±è´¥ã€‚"));
                    };
                });
            } catch (error) {
                console.error("getUserMedia é”™è¯¯:", error);
                loadingMessage.innerText = `é”™è¯¯: ${error.message}`;
                throw error; 
            }
        }

        // --- ä¸»å¯åŠ¨å‡½æ•° (ä¸å˜) ---
        async function main() {
            try {
                console.log('æ­£åœ¨åŠ è½½æ¨¡å‹...');
                model = await cocoSsd.load();
                console.log('æ¨¡å‹åŠ è½½å®Œæ¯•ã€‚');
                loadingMessage.innerText = 'æ¨¡å‹åŠ è½½å®Œæ¯•...';

                await startCamera(currentFacingMode); 
                
                loadingMessage.style.display = 'none'; 
                countDisplay.style.display = 'block'; 
                document.getElementById('controls-overlay').style.display = 'flex';
                
                sessionStartTime = new Date(); 
                startDataLogger(); 
                runDetection(); 
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // å¯åŠ¨ç¨‹åº
        main();

        // --- âœ¨ äº‹ä»¶ç›‘å¬å™¨ (å·²æ›´æ–°) ---

        // å…³é—­æ¨¡æ€æ¡†
        closeModalButton.addEventListener('click', hideModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                hideModal();
            }
        });

        // é‡ç½®æŒ‰é’®
        resetButton.addEventListener('click', () => {
            console.log('è®¡æ•°å·²é‡ç½®');
            stopDetection(); 
            resetTrackerState(); 
            runDetection(); 
        });
        
        // ç¿»è½¬æ‘„åƒå¤´æŒ‰é’®
        flipButton.addEventListener('click', async () => {
            console.log('æ­£åœ¨ç¿»è½¬æ‘„åƒå¤´...');
            stopDetection(); 
            stopDataLogger(); 

            loadingMessage.innerText = 'æ­£åœ¨ç¿»è½¬é•œå¤´...';
            loadingMessage.style.display = 'block';
            countDisplay.style.display = 'none';
            document.getElementById('controls-overlay').style.display = 'none';
            
            try {
                const newFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                await startCamera(newFacingMode); // âœ¨ ä¿®å¤äº†æˆªæ–­é”™è¯¯
                
                resetTrackerState(); 
                
                loadingMessage.style.display = 'none';
                countDisplay.style.display = 'block';
                document.getElementById('controls-overlay').style.display = 'flex';

                runDetection(); 
                
            } catch (error) {
                console.error('ç¿»è½¬æ‘„åƒå¤´å¤±è´¥:', error);
                loadingMessage.innerText = `ç¿»è½¬å¤±è´¥: ${error.message}`;
                document.getElementById('controls-overlay').style.display = 'flex';
            }
        });

        // "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®
        reportButton.addEventListener('click', () => {
            showModal(); // å¼¹å‡ºç©ºç™½æ¨¡æ€æ¡†
            
            // âœ¨ è®¾ç½®é»˜è®¤é€‰é¡¹ä¸º 5 åˆ†é’Ÿ
            chartIntervalSelect.value = "300000"; // 5 minutes
            
            // âœ¨ æ¸²æŸ“é»˜è®¤å›¾è¡¨
            renderChart(); 
        });

        // âœ¨ æ–°å¢ï¼šç›‘å¬æ¨¡æ€æ¡†å†…éƒ¨ä¸‹æ‹‰èœå•çš„å˜åŒ–
        chartIntervalSelect.addEventListener('change', () => {
            renderChart(); // âœ¨ é‡æ–°æ¸²æŸ“å›¾è¡¨
        });

        // âœ¨ æ–°å¢ï¼šç›‘å¬å…¨å±æŒ‰é’®
        fullscreenButton.addEventListener('click', toggleFullScreen);
        
        // âœ¨ æ–°å¢ï¼šç›‘å¬é”å®šæŒ‰é’®
        lockButton.addEventListener('click', toggleLock);

        // æ—‹è½¬å¤„ç† (ä¸å˜)
        const resizeObserver = new ResizeObserver(() => {
            if (video.videoWidth > 0 && 
                (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)) {
                console.log(`æ£€æµ‹åˆ°æ—‹è½¬/è°ƒæ•´å¤§å°ã€‚é‡è®¾ç”»å¸ƒåˆ†è¾¨ç‡ä¸º: ${video.videoWidth}x${video.videoHeight}`);
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
        });
        resizeObserver.observe(video);
    </script>
</body>
</html>