<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- å…³é”®ï¼šè®¾ç½®è§†å£ä»¥æ”¯æŒç§»åŠ¨è®¾å¤‡å’Œæ—‹è½¬ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>äººæ•°ç»Ÿè®¡ (âœ¨ AIç‰ˆ)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <!-- âœ¨ æ–°å¢ï¼šå¼•å…¥ Chart.js åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <style>
        /* å…³é”®ï¼šè®©é¡µé¢å…¨å±å¹¶ç¦æ­¢æ»šåŠ¨ */
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* ç¦æ­¢æ»šåŠ¨æ¡ */
            background-color: #000; /* é»‘è‰²èƒŒæ™¯ */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }

        /* å…³é”®ï¼šå®¹å™¨ç°åœ¨å¡«æ»¡æ•´ä¸ªå±å¹• */
        #container {
            position: fixed; /* å›ºå®šåœ¨å±å¹•ä¸Š */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* åœ¨åº•å±‚ */
        }

        /* å…³é”®ï¼šè§†é¢‘å’Œç”»å¸ƒä¹Ÿå¡«æ»¡å®¹å™¨ */
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* æ³¨æ„: æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨ 'object-fit: cover'ï¼Œ
               è€Œæ˜¯è®©è§†é¢‘è¢«æ‹‰ä¼¸ä»¥å¡«æ»¡å±å¹•ã€‚
               è¿™æ ·å¯ä»¥ä¿è¯ç”»å¸ƒåæ ‡å’Œè§†é¢‘åæ ‡
               100% åŒ¹é…ï¼Œå³ä½¿æ¯”ä¾‹å¤±è°ƒã€‚
            */
        }

        video {
            z-index: 1;
            /* é€‚é…å‰ç½®æ‘„åƒå¤´é•œåƒ */
            transform: scaleX(1); 
        }
        
        /* å…³é”®ï¼šä¸ºå‰ç½®æ‘„åƒå¤´é•œåƒç¿»è½¬ç”»å¸ƒ */
        canvas.mirrored {
            transform: scaleX(-1);
        }

        canvas {
            z-index: 2;
            background-color: transparent;
        }

        /* --- âœ¨ å¸ƒå±€æ”¹åŠ¨ --- */

        /* å…³é”®ï¼šå·¦ä¸Šè§’çš„äººæ•°ç»Ÿè®¡æ¡† */
        #count-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        /* å°æ–¹æ¡†å†…çš„å…ƒç´ æ ·å¼ */
        #loading-message {
            margin: 0;
            font-size: 0.9em;
        }

        #count {
            margin: 0;
            /* âœ¨ å­—ä½“æ”¹å° */
            font-size: 1.2em; 
            font-weight: bold;
            color: #00FFFF; /* äº®é’è‰²ï¼ŒåŒ¹é…æ–¹æ¡† */
            display: none; /* é»˜è®¤éšè—ï¼ŒåŠ è½½åæ˜¾ç¤º */
        }

        /* å…³é”®ï¼šå³ä¸‹è§’çš„æŒ‰é’®æ§åˆ¶æ¡† */
        #controls-overlay {
            position: absolute;
            bottom: 20px;
            right: 15px;
            z-index: 10;
            display: flex;
            flex-direction: row; /* æ°´å¹³æ’åˆ— */
            gap: 10px; /* æŒ‰é’®é—´è· */
            align-items: center; /* âœ¨ å‚ç›´å±…ä¸­å¯¹é½ */
        }

        /* æŒ‰é’®é€šç”¨æ ·å¼ */
        .info-button {
            /* âœ¨ ç§»é™¤ margin-top, å®½åº¦è‡ªé€‚åº” */
            padding: 8px 12px; 
            font-size: 0.9em;
            font-weight: bold;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* âœ¨ "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®æ ·å¼ (åŸ "ç”ŸæˆæŠ¥å‘Š") */
        #reportButton {
            background-color: #f44336; /* çº¢è‰² */
        }
        #reportButton:hover {
            background-color: #da190b;
        }

        /* ç¿»è½¬æŒ‰é’®æ ·å¼ */
        #flipButton {
            background-color: #9C27B0; /* ç´«è‰² */
        }
        #flipButton:hover {
            background-color: #7B1FA2;
        }

        /* é‡ç½®æŒ‰é’®æ ·å¼ */
        #resetButton {
            background-color: #007bff; /* è“è‰² */
        }
        #resetButton:hover {
            background-color: #0056b3;
        }
        
        /* --- âœ¨ ç§»é™¤ä¸»ç•Œé¢çš„ä¸‹æ‹‰æ¡†æ ·å¼ --- */
        /* #intervalSelect {...} å·²åˆ é™¤ */

        
        /* --- âœ¨ æ¨¡æ€æ¡† (Modal) æ ·å¼ä¿®æ”¹ --- */
        
        /* æ¨¡æ€æ¡†é®ç½©å±‚ */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
        }

        /* æ¨¡æ€æ¡†æœ¬ä½“ */
        #gemini-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            
            background-color: #fff;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            width: 90%; /* é€‚é…æ‰‹æœºå®½åº¦ */
            max-width: 500px;
        }
        
        /* âœ¨ æ¨¡æ€æ¡†æ ‡é¢˜ (å·²æ·»åŠ ID) */
        #gemini-modal h3 {
            margin-top: 0;
            color: #007bff;
        }

        /* âœ¨ æ–°å¢ï¼šæ¨¡æ€æ¡†å†…éƒ¨çš„æ§åˆ¶æ  */
        #chart-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        #chart-controls label {
            font-size: 0.9em;
            color: #555;
            font-weight: bold;
        }
        #chart-controls select {
            padding: 5px 8px;
            font-size: 0.9em;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        
        /* âœ¨ æ–°å¢å›¾è¡¨å®¹å™¨æ ·å¼ */
        #chart-container {
            width: 100%;
            max-height: 400px; /* é™åˆ¶å›¾è¡¨æœ€å¤§é«˜åº¦ */
            position: relative; /* âœ¨ è®¾ä¸ºç›¸å¯¹å®šä½ï¼Œç”¨äºå†…éƒ¨å…ƒç´ å®šä½ */
            min-height: 100px; /* âœ¨ é¿å…æ— æ•°æ®æ—¶é«˜åº¦åå¡Œ */
        }
        
        /* âœ¨ æ–°å¢ï¼šæ— æ•°æ®æ—¶çš„æç¤ºæ–‡æœ¬ */
        #chart-no-data {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 16px;
            text-align: center;
            width: 100%;
        }

        /* âœ¨ å½“ç”»å¸ƒæ˜¾ç¤ºæ—¶ï¼Œéšè—æ— æ•°æ®æç¤º */
        canvas:not(.modal-hidden) + #chart-no-data {
            display: none;
        }

        #close-modal-button {
            margin-top: 15px;
            padding: 8px 15px;
            font-weight: bold;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            float: right; /* æŒ‰é’®é å³ */
        }
        
        .modal-hidden {
            display: none;
        }
        /* --- ç»“æŸï¼šæ¨¡æ€æ¡†æ ·å¼ --- */

    </style>
</head>
<body>
    
    <!-- è§†é¢‘å’Œç”»å¸ƒå®¹å™¨ (å…¨å±) -->
    <div id="container">
        <video autoplay playsinline muted id="webcam"></video>
        <canvas id="canvas"></canvas> 
    </div>
    
    <!-- å…³é”®ï¼šå·¦ä¸Šè§’ä¿¡æ¯æ¡† -->
    <div id="count-overlay">
        <p id="loading-message">æ­£åœ¨åŠ è½½AIæ¨¡å‹...</p>
        <h2 id="count">ç´¯è®¡äººæ•°: 0</h2>
    </div>

    <!-- å…³é”®ï¼šå³ä¸‹è§’æ§åˆ¶æ¡† (ä¸‹æ‹‰æ¡†å·²ç§»é™¤) -->
    <div id="controls-overlay">
        <button id="reportButton" class="info-button">âœ¨ ç”Ÿæˆå›¾è¡¨</button>
        <button id="flipButton" class="info-button">ğŸ”„ ç¿»è½¬é•œå¤´</button>
        <button id="resetButton" class="info-button">é‡ç½®è®¡æ•°</button>
    </div>

    <!-- âœ¨ æ¨¡æ€æ¡† (Modal) - å†…å®¹å·²ä¿®æ”¹ -->
    <div id="modal-overlay" class="modal-hidden"></div>
    <div id="gemini-modal" class="modal-hidden">
        <!-- âœ¨ æ ‡é¢˜å·²ä¿®æ”¹ä¸ºåŠ¨æ€ -->
        <h3 id="chart-modal-title">äººæµå›¾è¡¨</h3>
        
        <!-- âœ¨ æ–°å¢ï¼šæ¨¡æ€æ¡†å†…éƒ¨çš„é—´éš”é€‰æ‹©å™¨ -->
        <div id="chart-controls">
            <label for="chartIntervalSelect">é€‰æ‹©é—´éš”:</label>
            <select id="chartIntervalSelect">
                <option value="120000">æ¯2åˆ†é’Ÿ</option>
                <option value="300000">æ¯5åˆ†é’Ÿ</option>
                <option value="600000">æ¯10åˆ†é’Ÿ</option>
                <option value="1800000">æ¯30åˆ†é’Ÿ</option>
                <option value="3600000">æ¯å°æ—¶</option>
            </select>
        </div>
        
        <div id="chart-container">
            <canvas id="chart-canvas"></canvas>
            <p id="chart-no-data" class="modal-hidden">æš‚æ— æ•°æ®ï¼Œè¯·è‡³å°‘ç­‰å¾…ä¸€ä¸ªå‘¨æœŸåå†è¯•ã€‚</p>
        </div>
        <button id="close-modal-button">å…³é—­</button>
    </div>

    <script>
        // è·å–HTMLä¸­çš„å…ƒç´ 
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const countDisplay = document.getElementById('count');
        const loadingMessage = document.getElementById('loading-message');
        const resetButton = document.getElementById('resetButton'); 

        // âœ¨ æŒ‰é’®
        const reportButton = document.getElementById('reportButton');
        
        // âœ¨ Modal å…ƒç´ 
        const modalOverlay = document.getElementById('modal-overlay');
        const geminiModal = document.getElementById('gemini-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const chartIntervalSelect = document.getElementById('chartIntervalSelect'); // âœ¨ æ¨¡æ€æ¡†å†…çš„ä¸‹æ‹‰æ¡†
        
        // âœ¨ ç¿»è½¬æŒ‰é’®
        const flipButton = document.getElementById('flipButton');
        // âœ¨ intervalSelect å·²ä»è¿™é‡Œç§»é™¤

        let model = null; 
        let detectionTimeoutId = null; 
        const DETECTION_INTERVAL = 100; // 100æ¯«ç§’ = 10 FPS

        // --- è·Ÿè¸ªå™¨å˜é‡ ---
        let cumulativeCount = 0;    
        let nextPersonId = 1;       
        let trackedPeople = []; 
        let sessionStartTime = null; 
        
        // --- âœ¨ æ‘„åƒå¤´çŠ¶æ€å˜é‡ ---
        let currentFacingMode = 'environment'; // é»˜è®¤ä½¿ç”¨åç½®
        let currentStream = null; // å­˜å‚¨å½“å‰çš„è§†é¢‘æµ

        const RELATIVE_MATCH_THRESHOLD = 0.8; 
        const MAX_FRAMES_UNSEEN = 100; // 100 å¸§ (10 ç§’)
        
        // --- âœ¨ å›¾è¡¨æ•°æ®ç›¸å…³å˜é‡ ---
        const BASE_LOG_INTERVAL = 60000; // âœ¨ å…³é”®ï¼šæ•°æ®è®°å½•åŸºç¡€é—´éš” (1 åˆ†é’Ÿ)
        let flowData = []; // å­˜å‚¨ { timestamp: Date, flow: int }
        let lastLoggedCount = 0;
        let dataLoggerInterval = null;
        let chartInstance = null; // å­˜å‚¨ Chart.js å®ä¾‹

        // --- âœ¨ Modal æ§åˆ¶å‡½æ•° (ä¸å˜) ---
        function showModal() {
            modalOverlay.classList.remove('modal-hidden');
            geminiModal.classList.remove('modal-hidden');
        }

        function hideModal() {
            modalOverlay.classList.add('modal-hidden');
            geminiModal.classList.add('modal-hidden'); 
            // é”€æ¯å›¾è¡¨å®ä¾‹ä»¥é‡Šæ”¾èµ„æº
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
        }
        
        // --- âœ¨ ä¼šè¯æ—¶é•¿å‡½æ•° (ä¸å˜) ---
        function getSessionDuration() {
            if (!sessionStartTime) return "0 ç§’";
            const diff = new Date() - sessionStartTime;
            const seconds = Math.floor((diff / 1000) % 60);
            const minutes = Math.floor((diff / (1000 * 60)) % 60);
            const hours = Math.floor((diff / (1000 * 60 * 60)));
            let durationStr = "";
            if (hours > 0) durationStr += `${hours} å°æ—¶ `;
            if (minutes > 0) durationStr += `${minutes} åˆ†é’Ÿ `;
            if (seconds > 0 || durationStr === "") durationStr += `${seconds} ç§’`;
            return durationStr.trim();
        }

        // --- è¾…åŠ©å‡½æ•° (ä¸å˜) ---
        function getBoxCenter(box) {
            return {
                x: box[0] + box[2] / 2,
                y: box[1] + box[3] / 2
            };
        }
        function getCenterDistance(center1, center2) {
            const dx = center1.x - center2.x;
            const dy = center1.y - center2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        function drawBoundingBox(box, personId, score) {
            const [x, y, width, height] = box;
            context.strokeStyle = '#00FFFF'; 
            context.lineWidth = 2;
            context.strokeRect(x, y, width, height); 
            
            context.fillStyle = '#00FFFF';
            context.font = '16px Arial';
            const label = `ID:${personId} (${Math.round(score * 100)}%)`;
            
            const textX = x;
            const textY = y > 16 ? y - 5 : 16;
            
            context.save(); 
            if (currentFacingMode === 'user') {
                const textWidth = context.measureText(label).width;
                context.translate(textX + (textWidth / 2), textY);
                context.scale(-1, 1);
                context.textAlign = "center";
                context.fillText(label, 0, 0);
            } else {
                context.textAlign = "left";
                context.fillText(label, textX, textY); 
            }
            context.restore(); 
        }

        // --- æ ¸å¿ƒæ£€æµ‹é€»è¾‘ (ä¸å˜) ---
        async function runDetection() {
            if (!model || !video.HAVE_ENOUGH_DATA) {
                detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
                return;
            }
            const predictions = await model.detect(video);
            context.clearRect(0, 0, canvas.width, canvas.height);
            let currentFramePeople = []; 
            for (let prediction of predictions) {
                if (prediction.class === 'person' && prediction.score > 0.5) { 
                    currentFramePeople.push({
                        box: prediction.bbox,
                        score: prediction.score,
                        center: getBoxCenter(prediction.bbox)
                    });
                }
            }
            let newTrackedPeople = []; 
            let matchedCurrentFrameIndices = new Set(); 
            for (let i = 0; i < trackedPeople.length; i++) {
                const trackedPerson = trackedPeople[i];
                let bestMatch = { index: -1, distance: Infinity };
                for (let j = 0; j < currentFramePeople.length; j++) {
                    if (matchedCurrentFrameIndices.has(j)) continue; 
                    const currentPerson = currentFramePeople[j];
                    const distance = getCenterDistance(currentPerson.center, trackedPerson.lastSeenCenter);
                    if (distance < bestMatch.distance) {
                        bestMatch = { index: j, distance: distance };
                    }
                }
                const personSize = (trackedPerson.lastSeenBox[2] + trackedPerson.lastSeenBox[3]) / 2;
                const MATCH_THRESHOLD = personSize * RELATIVE_MATCH_THRESHOLD;
                if (bestMatch.index !== -1 && bestMatch.distance < MATCH_THRESHOLD) {
                    const matchedCurrentPerson = currentFramePeople[bestMatch.index];
                    trackedPerson.lastSeenBox = matchedCurrentPerson.box;
                    trackedPerson.lastSeenCenter = matchedCurrentPerson.center;
                    trackedPerson.score = matchedCurrentPerson.score;
                    trackedPerson.framesUnseen = 0; 
                    newTrackedPeople.push(trackedPerson); 
                    matchedCurrentFrameIndices.add(bestMatch.index); 
                } else {
                    trackedPerson.framesUnseen++;
                    if (trackedPerson.framesUnseen < MAX_FRAMES_UNSEEN) {
                        newTrackedPeople.push(trackedPerson); 
                    }
                }
            }
            for (let i = 0; i < currentFramePeople.length; i++) {
                if (!matchedCurrentFrameIndices.has(i)) {
                    const newPerson = currentFramePeople[i];
                    cumulativeCount++; 
                    newTrackedPeople.push({
                        id: nextPersonId++, 
                        lastSeenBox: newPerson.box,
                        lastSeenCenter: newPerson.center,
                        score: newPerson.score,
                        framesUnseen: 0 
                    });
                }
            }
            trackedPeople = newTrackedPeople;
            for (const person of trackedPeople) {
                if (person.framesUnseen === 0) {
                     drawBoundingBox(person.lastSeenBox, person.id, person.score);
                }
            }
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            detectionTimeoutId = setTimeout(runDetection, DETECTION_INTERVAL);
        }

        function stopDetection() {
            if (detectionTimeoutId) {
                clearTimeout(detectionTimeoutId);
                detectionTimeoutId = null;
            }
        }

        // --- âœ¨ æ•°æ®è®°å½•å™¨åŠŸèƒ½ (å·²æ›´æ–°) ---
        function logData() {
            const currentFlow = cumulativeCount - lastLoggedCount;
            flowData.push({ 
                timestamp: new Date(), 
                flow: currentFlow 
            });
            lastLoggedCount = cumulativeCount;
            console.log('å·²è®°å½•äººæµæ•°æ®(æ¯1åˆ†é’Ÿ):', flowData[flowData.length - 1]);
        }

        function startDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            flowData = [];
            lastLoggedCount = 0;
            
            console.log(`æ•°æ®è®°å½•å™¨å·²å¯åŠ¨ï¼Œæ¯ 1 åˆ†é’Ÿè®°å½•ä¸€æ¬¡ã€‚`);
            // âœ¨ å§‹ç»ˆä½¿ç”¨åŸºç¡€é—´éš” (1 åˆ†é’Ÿ)
            dataLoggerInterval = setInterval(logData, BASE_LOG_INTERVAL);
        }

        function stopDataLogger() {
            if (dataLoggerInterval) clearInterval(dataLoggerInterval);
            dataLoggerInterval = null;
            console.log('æ•°æ®è®°å½•å™¨å·²åœæ­¢ã€‚');
        } 
        
        // --- âœ¨ æ–°å¢ï¼šå›¾è¡¨æ•°æ®èšåˆå‡½æ•° ---
        // æ­¤å‡½æ•°è·å–1åˆ†é’Ÿçš„åŸå§‹æ•°æ®ï¼Œå¹¶æŒ‰éœ€èšåˆæˆæ›´å¤§çš„æ—¶é—´å—
        function aggregateData(targetIntervalMs) {
            // e.g., "æ¯5åˆ†é’Ÿ" (300000) / "æ¯1åˆ†é’Ÿ" (60000) = 5
            // è¿™æ„å‘³ç€æˆ‘ä»¬è¦æŠŠ 5 ä¸ªæ•°æ®ç‚¹åˆå¹¶æˆ 1 ä¸ª
            const aggregationFactor = targetIntervalMs / BASE_LOG_INTERVAL;

            if (flowData.length === 0) {
                return { labels: [], data: [] };
            }
            
            // ç¡®ä¿ aggregationFactor æ˜¯æ•´æ•°, å°½ç®¡åœ¨è¿™ä¸ªåº”ç”¨é‡Œå®ƒæ€»æ˜¯
            if (aggregationFactor < 1) {
                 console.warn("èšåˆé—´éš”å°äºåŸºç¡€é—´éš”");
                 return { labels: [], data: [] };
            }

            let aggregatedFlow = [];
            let aggregatedLabels = [];
            let currentFlowSum = 0;
            let lastTimestamp = null;

            for (let i = 0; i < flowData.length; i++) {
                currentFlowSum += flowData[i].flow;
                lastTimestamp = flowData[i].timestamp;
                
                // (i + 1) % aggregationFactor === 0  => ä¾‹å¦‚, factor=5, é‚£ä¹ˆåœ¨ i=4 (ç¬¬5ä¸ª) æ—¶è§¦å‘
                // OR å¦‚æœè¿™æ˜¯æœ€åä¸€ä¸ªæ•°æ®ç‚¹ (ä¸ºäº†æ¨é€å‰©ä½™çš„æ•°æ®)
                if ((i + 1) % aggregationFactor === 0 || i === flowData.length - 1) {
                    aggregatedFlow.push(currentFlowSum);
                    aggregatedLabels.push(lastTimestamp.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }));
                    currentFlowSum = 0; // é‡ç½®æ€»å’Œ
                }
            }
            
            return { labels: aggregatedLabels, data: aggregatedFlow };
        }

        
        // --- âœ¨ æ–°å¢ï¼šå›¾è¡¨æ¸²æŸ“å‡½æ•° (æ›¿ä»£æ—§çš„ showChartModal é€»è¾‘) ---
        function renderChart() {
            // è·å–HTMLå…ƒç´ 
            const chartCanvas = document.getElementById('chart-canvas');
            const noDataText = document.getElementById('chart-no-data');
            
            // ä»æ¨¡æ€æ¡†ä¸‹æ‹‰èœå•è·å–å½“å‰å€¼
            const selectedIntervalMs = parseInt(chartIntervalSelect.value, 10);
            const selectedIntervalText = chartIntervalSelect.options[chartIntervalSelect.selectedIndex].text;

            // æ›´æ–°æ¨¡æ€æ¡†æ ‡é¢˜
            document.getElementById('chart-modal-title').innerText = `äººæµå›¾è¡¨ (${selectedIntervalText})`;

            // å…ˆé”€æ¯æ—§å®ä¾‹
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }

            // âœ¨ è°ƒç”¨æ–°çš„èšåˆå™¨
            const { labels, data } = aggregateData(selectedIntervalMs);

            // æ£€æŸ¥æ˜¯å¦æœ‰æ•°æ®
            if (data.length === 0) {
                noDataText.classList.remove('modal-hidden'); 
                chartCanvas.classList.add('modal-hidden'); 
                return; // æ²¡æœ‰æ•°æ®ï¼Œä¸æ¸²æŸ“
            }

            noDataText.classList.add('modal-hidden'); 
            chartCanvas.classList.remove('modal-hidden'); 

            requestAnimationFrame(() => {
                const ctx = chartCanvas.getContext('2d');
                chartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `æ¯ ${selectedIntervalText.replace('æ¯', '')} æ–°å¢äººæµ`,
                            data: data,
                            fill: true,
                            backgroundColor: 'rgba(0, 123, 255, 0.2)',
                            borderColor: 'rgba(0, 123, 255, 1)',
                            borderWidth: 2,
                            tension: 0.1 
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'æ–°å¢äººæ•°'
                                },
                                ticks: {
                                    stepSize: 1 
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'æ—¶é—´ç‚¹ (å‘¨æœŸç»“æŸæ—¶)'
                                }
                            }
                        }
                    }
                });
            });
        }


        // --- âœ¨ é‡ç½®è·Ÿè¸ªå™¨çŠ¶æ€çš„å‡½æ•° (ä¸å˜) ---
        function resetTrackerState() {
            cumulativeCount = 0;
            nextPersonId = 1;       
            trackedPeople = [];     
            sessionStartTime = new Date(); 
            countDisplay.innerText = `ç´¯è®¡äººæ•°: ${cumulativeCount}`;
            context.clearRect(0, 0, canvas.width, canvas.height); 
            
            // é‡ç½®æ•°æ®è®°å½•å™¨ (å°†ä½¿ç”¨1åˆ†é’Ÿçš„åŸºç¡€é—´éš”)
            stopDataLogger();
            startDataLogger();
        }

        // --- âœ¨ å¯åŠ¨æ‘„åƒå¤´çš„å‡½æ•° (ä¸å˜) ---
        async function startCamera(facingMode) {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            currentFacingMode = facingMode; 
            const constraints = { 
                video: { 
                    facingMode: currentFacingMode,
                    width: { ideal: 640 }, 
                    height: { ideal: 480 },
                    maxWidth: 640,
                    maxHeight: 480
                },
                audio: false 
            };
            
            if (currentFacingMode === 'user') {
                video.style.transform = "scaleX(-1)";
                canvas.classList.add("mirrored");
            } else {
                video.style.transform = "scaleX(1)";
                canvas.classList.remove("mirrored");
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream; 
                video.srcObject = stream;
                return new Promise((resolve, reject) => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        console.log(`æ‘„åƒå¤´å·²å¯åŠ¨ (${currentFacingMode}): ${video.videoWidth}x${video.videoHeight}`);
                        resolve(true);
                    };
                    video.onerror = (e) => {
                        console.error("è§†é¢‘å…ƒç´ é”™è¯¯:", e);
                        reject(new Error("è§†é¢‘åŠ è½½æµå¤±è´¥ã€‚"));
                    };
                });
            } catch (error) {
                console.error("getUserMedia é”™è¯¯:", error);
                loadingMessage.innerText = `é”™è¯¯: ${error.message}`;
                throw error; 
            }
        }

        // --- ä¸»å¯åŠ¨å‡½æ•° (ä¸å˜) ---
        async function main() {
            try {
                console.log('æ­£åœ¨åŠ è½½æ¨¡å‹...');
                model = await cocoSsd.load();
                console.log('æ¨¡å‹åŠ è½½å®Œæ¯•ã€‚');
                loadingMessage.innerText = 'æ¨¡å‹åŠ è½½å®Œæ¯•...';

                await startCamera(currentFacingMode); 
                
                loadingMessage.style.display = 'none'; 
                countDisplay.style.display = 'block'; 
                document.getElementById('controls-overlay').style.display = 'flex';
                
                sessionStartTime = new Date(); 
                startDataLogger(); // âœ¨ å¯åŠ¨æ•°æ®è®°å½•å™¨ (å°†ä½¿ç”¨1åˆ†é’Ÿçš„åŸºç¡€é—´éš”)
                runDetection(); 
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
            }
        }

        // å¯åŠ¨ç¨‹åº
        main();

        // --- âœ¨ äº‹ä»¶ç›‘å¬å™¨ (å·²æ›´æ–°) ---

        // å…³é—­æ¨¡æ€æ¡†
        closeModalButton.addEventListener('click', hideModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                hideModal();
            }
        });

        // é‡ç½®æŒ‰é’®
        resetButton.addEventListener('click', () => {
            console.log('è®¡æ•°å·²é‡ç½®');
            stopDetection(); 
            resetTrackerState(); 
            runDetection(); 
        });
        
        // ç¿»è½¬æ‘„åƒå¤´æŒ‰é’®
        flipButton.addEventListener('click', async () => {
            console.log('æ­£åœ¨ç¿»è½¬æ‘„åƒå¤´...');
            stopDetection(); 
            stopDataLogger(); 

            loadingMessage.innerText = 'æ­£åœ¨ç¿»è½¬é•œå¤´...';
            loadingMessage.style.display = 'block';
            countDisplay.style.display = 'none';
            document.getElementById('controls-overlay').style.display = 'none';
            
            try {
                const newFacingMode = (currentFacingMode === 'environment') ? 'user' : 'environment';
                await startCamera(newFacingMode); // âœ¨ ä¿®å¤äº†æ‹¼å†™é”™è¯¯ (newFacingBode -> newFacingMode)
                
                resetTrackerState(); 
                
                loadingMessage.style.display = 'none';
                countDisplay.style.display = 'block';
                document.getElementById('controls-overlay').style.display = 'flex';

                runDetection(); 
                
            } catch (error) {
                console.error('ç¿»è½¬æ‘„åƒå¤´å¤±è´¥:', error);
                loadingMessage.innerText = `ç¿»è½¬å¤±è´¥: ${error.message}`;
                document.getElementById('controls-overlay').style.display = 'flex';
            }
        });

        // "ç”Ÿæˆå›¾è¡¨" æŒ‰é’®
        reportButton.addEventListener('click', () => {
            showModal(); // å¼¹å‡ºç©ºç™½æ¨¡æ€æ¡†
            
            // âœ¨ è®¾ç½®é»˜è®¤é€‰é¡¹ä¸º 5 åˆ†é’Ÿ
            chartIntervalSelect.value = "300000"; // 5 minutes
            
            // âœ¨ æ¸²æŸ“é»˜è®¤å›¾è¡¨
            renderChart(); 
        });

        // âœ¨ æ–°å¢ï¼šç›‘å¬æ¨¡æ€æ¡†å†…éƒ¨ä¸‹æ‹‰èœå•çš„å˜åŒ–
        chartIntervalSelect.addEventListener('change', () => {
            renderChart(); // âœ¨ é‡æ–°æ¸²æŸ“å›¾è¡¨
        });

        // æ—‹è½¬å¤„ç† (ä¸å˜)
        const resizeObserver = new ResizeObserver(() => {
            if (video.videoWidth > 0 && 
                (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight)) {
                console.log(`æ£€æµ‹åˆ°æ—‹è½¬/è°ƒæ•´å¤§å°ã€‚é‡è®¾ç”»å¸ƒåˆ†è¾¨ç‡ä¸º: ${video.videoWidth}x${video.videoHeight}`);
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }
        });
        resizeObserver.observe(video);
    </script>
</body>
</html>